<?php

/**
 * @file
 * Mark-a-Spot Group module.
 *
 * Provides group-based access control for service requests using the Group
 * module. Includes auto-membership functionality for users with the
 * "All Groups Member" field enabled.
 */

declare(strict_types=1);

use Drupal\group\Entity\Group;
use Drupal\group\Entity\GroupInterface;
use Drupal\group\Entity\GroupRelationshipInterface;
use Drupal\node\NodeInterface;
use Drupal\user\UserInterface;

/**
 * Implements hook_user_insert().
 *
 * When a new user is created with the "All Groups Member" field enabled,
 * automatically add them to all existing groups with the admin role.
 */
function markaspot_group_user_insert(UserInterface $account): void {
  _markaspot_group_handle_user_membership($account);
}

/**
 * Implements hook_user_update().
 *
 * When an existing user is updated with the "All Groups Member" field enabled,
 * automatically add them to all groups they are not yet a member of.
 */
function markaspot_group_user_update(UserInterface $account): void {
  // Check if the field exists before accessing it.
  if (!$account->hasField('field_all_groups_member')) {
    return;
  }

  // Check if the field value changed from FALSE to TRUE.
  $original = $account->original ?? NULL;
  $original_value = $original?->hasField('field_all_groups_member')
    ? (bool) $original->get('field_all_groups_member')->value
    : FALSE;
  $new_value = (bool) $account->get('field_all_groups_member')->value;

  // Only process if the field was just enabled.
  if ($new_value && !$original_value) {
    _markaspot_group_handle_user_membership($account);
  }
}

/**
 * Implements hook_ENTITY_TYPE_insert() for group entities.
 *
 * When a new group is created, automatically add all users with
 * the "All Groups Member" field enabled as members with the admin role.
 */
function markaspot_group_group_insert(GroupInterface $group): void {
  _markaspot_group_add_all_groups_members_to_group($group);
}

/**
 * Helper function to add a user to all groups if they have the field enabled.
 *
 * Applies different rules based on group type:
 * - JUR (Jurisdiction): Only user 1 (uid=1) is automatically added.
 * - ORG (Organisation): All users with field_all_groups_member are added.
 *
 * @param \Drupal\user\UserInterface $account
 *   The user account to process.
 */
function _markaspot_group_handle_user_membership(UserInterface $account): void {
  // Check if user has the "All Groups Member" field enabled.
  if (!$account->hasField('field_all_groups_member')) {
    return;
  }

  $is_all_groups_member = (bool) $account->get('field_all_groups_member')->value;
  if (!$is_all_groups_member) {
    return;
  }

  // Load all groups and add the user as a member with admin role.
  $groups = Group::loadMultiple();
  foreach ($groups as $group) {
    // Check if user is allowed to be added to this group type.
    if (_markaspot_group_user_allowed_for_group($account, $group)) {
      _markaspot_group_add_member_to_group($group, $account);
    }
  }
}

/**
 * Helper function to add all "All Groups Member" users to a new group.
 *
 * Applies different rules based on group type:
 * - JUR (Jurisdiction): Only user 1 (uid=1) is automatically added.
 * - ORG (Organisation): All users with field_all_groups_member are added.
 *
 * @param \Drupal\group\Entity\GroupInterface $group
 *   The group to add members to.
 */
function _markaspot_group_add_all_groups_members_to_group(GroupInterface $group): void {
  /** @var \Drupal\Core\Entity\EntityTypeManagerInterface $entity_type_manager */
  $entity_type_manager = \Drupal::entityTypeManager();

  // Load all users with the "All Groups Member" field enabled.
  $user_storage = $entity_type_manager->getStorage('user');
  $query = $user_storage->getQuery()
    ->accessCheck(FALSE)
    ->condition('field_all_groups_member', TRUE)
    ->condition('status', 1);

  $uids = $query->execute();
  if (empty($uids)) {
    return;
  }

  /** @var \Drupal\user\UserInterface[] $users */
  $users = $user_storage->loadMultiple($uids);
  foreach ($users as $user) {
    // Check if user is allowed to be added to this group type.
    if (_markaspot_group_user_allowed_for_group($user, $group)) {
      _markaspot_group_add_member_to_group($group, $user);
    }
  }
}

/**
 * Checks if a user is allowed to be auto-added to a group based on type.
 *
 * Rules:
 * - JUR (Jurisdiction): Only user 1 (uid=1) is allowed.
 * - ORG (Organisation): All users with field_all_groups_member are allowed.
 * - Other group types: All users with field_all_groups_member are allowed.
 *
 * @param \Drupal\user\UserInterface $account
 *   The user account to check.
 * @param \Drupal\group\Entity\GroupInterface $group
 *   The group to check against.
 *
 * @return bool
 *   TRUE if the user is allowed to be added, FALSE otherwise.
 */
function _markaspot_group_user_allowed_for_group(UserInterface $account, GroupInterface $group): bool {
  $group_type_id = $group->bundle();

  // JUR groups: Only user 1 (uid=1) is allowed to be auto-added.
  if ($group_type_id === 'jur') {
    return (int) $account->id() === 1;
  }

  // ORG groups and other types: All users with field_all_groups_member allowed.
  return TRUE;
}

/**
 * Helper function to add a user to a group as member.
 *
 * In Group 3.x, admin permissions are handled via 'insider' scope roles
 * which automatically apply to all group members. Therefore we simply
 * add the user as a member without specifying a role.
 *
 * @param \Drupal\group\Entity\GroupInterface $group
 *   The group to add the member to.
 * @param \Drupal\user\UserInterface $account
 *   The user account to add.
 */
function _markaspot_group_add_member_to_group(GroupInterface $group, UserInterface $account): void {
  // Skip if user is already a member.
  if ($group->getMember($account)) {
    return;
  }

  // Add user as member. Admin permissions come from insider scope roles.
  $group->addMember($account);

  \Drupal::logger('markaspot_group')->notice(
    'Added user @user to group @group as member.',
    [
      '@user' => $account->getDisplayName(),
      '@group' => $group->label(),
    ]
  );
}

/**
 * Implements hook_node_presave().
 *
 * Syncs field_organisation to group relationship when a service_request
 * node is saved. This ensures that when the organisation field is changed,
 * the corresponding group relationship is created/updated/deleted.
 */
function markaspot_group_node_presave(NodeInterface $node): void {
  // Only process service_request nodes.
  if ($node->bundle() !== 'service_request') {
    return;
  }

  // Check if field_organisation exists on this node.
  if (!$node->hasField('field_organisation')) {
    return;
  }

  // Check if we're already syncing from relationship to field.
  // This prevents infinite loops.
  if (_markaspot_group_is_syncing()) {
    return;
  }

  // Get the new organisation group ID from the field.
  $new_group_id = NULL;
  if (!$node->get('field_organisation')->isEmpty()) {
    $new_group_id = $node->get('field_organisation')->target_id;
  }

  // For new nodes, we can't sync yet - need to wait until after save.
  // The relationship will be created in hook_node_insert.
  if ($node->isNew()) {
    // Store the group ID for later processing in hook_node_insert.
    $node->_markaspot_group_pending_sync = $new_group_id;
    return;
  }

  // For existing nodes, check the original value.
  $original_group_id = NULL;
  if (isset($node->original) && $node->original->hasField('field_organisation') && !$node->original->get('field_organisation')->isEmpty()) {
    $original_group_id = $node->original->get('field_organisation')->target_id;
  }

  // If nothing changed, skip sync.
  if ($new_group_id === $original_group_id) {
    return;
  }

  // Schedule sync for hook_node_update (we need the node to exist first).
  $node->_markaspot_group_sync_needed = TRUE;
  $node->_markaspot_group_new_group_id = $new_group_id;
  $node->_markaspot_group_original_group_id = $original_group_id;
}

/**
 * Implements hook_node_insert().
 *
 * Creates group relationship when a new service_request node is created
 * with field_organisation set.
 */
function markaspot_group_node_insert(NodeInterface $node): void {
  // Only process service_request nodes.
  if ($node->bundle() !== 'service_request') {
    return;
  }

  // Check if we have a pending sync from presave.
  if (!isset($node->_markaspot_group_pending_sync)) {
    return;
  }

  $group_id = $node->_markaspot_group_pending_sync;

  // If no group was set, nothing to do.
  if (empty($group_id)) {
    return;
  }

  // Check if we're already syncing.
  if (_markaspot_group_is_syncing()) {
    return;
  }

  // Create the group relationship.
  _markaspot_group_sync_field_to_relationship($node, $group_id, NULL);
}

/**
 * Implements hook_node_update().
 *
 * Updates group relationship when field_organisation changes on a
 * service_request node.
 */
function markaspot_group_node_update(NodeInterface $node): void {
  // Only process service_request nodes.
  if ($node->bundle() !== 'service_request') {
    return;
  }

  // Check if sync was flagged in presave.
  if (empty($node->_markaspot_group_sync_needed)) {
    return;
  }

  // Check if we're already syncing.
  if (_markaspot_group_is_syncing()) {
    return;
  }

  $new_group_id = $node->_markaspot_group_new_group_id ?? NULL;
  $original_group_id = $node->_markaspot_group_original_group_id ?? NULL;

  // Perform the sync.
  _markaspot_group_sync_field_to_relationship($node, $new_group_id, $original_group_id);
}

/**
 * Implements hook_ENTITY_TYPE_insert() for group_relationship entities.
 *
 * Syncs group relationship to field_organisation when a service_request
 * is added to an org group.
 */
function markaspot_group_group_relationship_insert(GroupRelationshipInterface $relationship): void {
  _markaspot_group_sync_relationship_to_field($relationship, 'insert');
}

/**
 * Implements hook_ENTITY_TYPE_delete() for group_relationship entities.
 *
 * Clears field_organisation when a service_request is removed from an org group.
 */
function markaspot_group_group_relationship_delete(GroupRelationshipInterface $relationship): void {
  _markaspot_group_sync_relationship_to_field($relationship, 'delete');
}

/**
 * Syncs field_organisation to group relationship.
 *
 * @param \Drupal\node\NodeInterface $node
 *   The service_request node.
 * @param int|null $new_group_id
 *   The new group ID to add the relationship to, or NULL to remove.
 * @param int|null $original_group_id
 *   The original group ID to remove the relationship from, or NULL.
 */
function _markaspot_group_sync_field_to_relationship(NodeInterface $node, ?int $new_group_id, ?int $original_group_id): void {
  // Set syncing flag to prevent loops.
  _markaspot_group_set_syncing(TRUE);

  try {
    $entity_type_manager = \Drupal::entityTypeManager();
    $relationship_storage = $entity_type_manager->getStorage('group_relationship');
    $group_type = _markaspot_group_get_org_group_type();
    $plugin_id = 'group_node:service_request';

    // Remove existing relationship if group changed or was cleared.
    if ($original_group_id !== NULL) {
      // Find and delete the old relationship.
      $old_relationships = $relationship_storage->loadByProperties([
        'entity_id' => $node->id(),
        'gid' => $original_group_id,
        'plugin_id' => $plugin_id,
      ]);

      foreach ($old_relationships as $relationship) {
        $relationship->delete();
      }
    }

    // Create new relationship if a group was set.
    if ($new_group_id !== NULL) {
      // Load the target group.
      $group = $entity_type_manager->getStorage('group')->load($new_group_id);

      if ($group && $group->bundle() === $group_type) {
        // Check if relationship already exists.
        $existing = $relationship_storage->loadByProperties([
          'entity_id' => $node->id(),
          'gid' => $new_group_id,
          'plugin_id' => $plugin_id,
        ]);

        if (empty($existing)) {
          // Create the relationship.
          $group->addRelationship($node, $plugin_id);

          \Drupal::logger('markaspot_group')->notice(
            'Created group relationship for node @nid in group @group (synced from field_organisation).',
            [
              '@nid' => $node->id(),
              '@group' => $group->label(),
            ]
          );
        }
      }
    }
  }
  finally {
    // Always reset syncing flag.
    _markaspot_group_set_syncing(FALSE);
  }
}

/**
 * Syncs group relationship changes back to field_organisation.
 *
 * @param \Drupal\group\Entity\GroupRelationshipInterface $relationship
 *   The group relationship entity.
 * @param string $operation
 *   The operation: 'insert' or 'delete'.
 */
function _markaspot_group_sync_relationship_to_field(GroupRelationshipInterface $relationship, string $operation): void {
  // Only process service_request node relationships.
  if ($relationship->getPluginId() !== 'group_node:service_request') {
    return;
  }

  // Get the group type and check if it's an org type.
  $group = $relationship->getGroup();
  if (!$group) {
    return;
  }

  $group_type = _markaspot_group_get_org_group_type();
  if ($group->bundle() !== $group_type) {
    return;
  }

  // Check if we're already syncing.
  if (_markaspot_group_is_syncing()) {
    return;
  }

  // Get the node.
  $entity = $relationship->getEntity();
  if (!$entity || !($entity instanceof NodeInterface)) {
    return;
  }

  // Check if node has the field.
  if (!$entity->hasField('field_organisation')) {
    return;
  }

  // Set syncing flag.
  _markaspot_group_set_syncing(TRUE);

  try {
    $current_value = $entity->get('field_organisation')->isEmpty() ? NULL : $entity->get('field_organisation')->target_id;
    $group_id = (int) $group->id();

    if ($operation === 'insert') {
      // Set the field to the new group.
      if ($current_value !== $group_id) {
        $entity->set('field_organisation', $group_id);
        $entity->save();

        \Drupal::logger('markaspot_group')->notice(
          'Updated field_organisation on node @nid to group @group (synced from relationship).',
          [
            '@nid' => $entity->id(),
            '@group' => $group->label(),
          ]
        );
      }
    }
    elseif ($operation === 'delete') {
      // Clear the field only if it points to this group.
      if ($current_value === $group_id) {
        $entity->set('field_organisation', NULL);
        $entity->save();

        \Drupal::logger('markaspot_group')->notice(
          'Cleared field_organisation on node @nid (synced from relationship deletion).',
          [
            '@nid' => $entity->id(),
          ]
        );
      }
    }
  }
  finally {
    _markaspot_group_set_syncing(FALSE);
  }
}

/**
 * Gets the configured org group type.
 *
 * Supports both 'org' (default) and legacy 'organisation' group type names.
 *
 * @return string
 *   The group type machine name.
 */
function _markaspot_group_get_org_group_type(): string {
  $config = \Drupal::config('markaspot_open311.settings');
  return $config->get('group_filter_type') ?? 'org';
}

/**
 * Checks if we're currently in a sync operation.
 *
 * Uses a static variable to prevent infinite loops during bidirectional sync.
 *
 * @return bool
 *   TRUE if currently syncing, FALSE otherwise.
 */
function _markaspot_group_is_syncing(): bool {
  return drupal_static(__FUNCTION__, FALSE);
}

/**
 * Sets the sync flag.
 *
 * @param bool $syncing
 *   Whether syncing is in progress.
 */
function _markaspot_group_set_syncing(bool $syncing): void {
  $static = &drupal_static('_markaspot_group_is_syncing', FALSE);
  $static = $syncing;
}
